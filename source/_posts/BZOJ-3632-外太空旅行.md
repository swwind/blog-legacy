layout: post
title: 'BZOJ 3632: 外太空旅行'
date: 2017-03-28 13:59:43
tags: 蒙特卡罗
categories: 题解
---
题面
-------------
在人类的触角伸向银河系的边缘之际，普通人上太空旅行已经变得稀松平常了。某理科试验班有n个人，现在班主任要从中选出尽量多的人去参加一次太空旅行活动。
可是n名同学并不是和平相处的。有的人，比如小A和小B整天狼狈为奸，是好朋友；但还有的人，比如杜鲁门和赫鲁晓夫就水火不相容。这n名同学，由于是理科生，都非常的理性，所以“朋友的朋友就是朋友”和“敌人的朋友就是敌人”这两句话对这些同学无效。换句话说，有可能小A和小B是朋友，小B和小C是朋友，但是小A和小C两人势如水火。
任意两个人之间要不就是敌人，要不就是朋友。
因为在太空船上发生人员斗殴事件是很恶劣也很危险的，因此选出来参加旅行活动的同学必须互相之间都是朋友。你的任务就是确定最多可以选多少人参加旅行。
Input
-------------
第一行一个整数n(1<=n<=50)。所有的同学按照1~n编号。
接下来若干行，每行两个用空格隔开的整数a, b(1<=a,b<=n)，表示a和b是朋友。
注意：如果一个数对(x,y)（或者(y,x)）没有在文件中出现，那么编号为x和y的两个同学就是敌人。

Output
-------------
仅仅一个数，即最多可以选多少人参加活动。
Sample Input
-------------
4
1 2
2 3
3 1
1 4
Sample Output
-------------
3
题解
-------------
传说有一种随机的算法叫蒙特卡罗、、
就是随机一下查找顺序，然后找一下再统计一下就行了
代码
-------------
```cpp
#include <bits/stdc++.h>
using namespace std;
int n, x, y, mp[60][60], vis[60], a[60];
int sum, ans;
int main(){
	scanf("%d", &n); srand(2333);
	while(scanf("%d%d", &x, &y) != EOF && x && y)
		mp[x][y] = mp[y][x] = 1;
	for(int i = 1; i <= n; ++i) a[i] = i;
	for(int k = 1; k <= 10000; ++k, ans = 0){
		for(int i = 1; i <= n; ++i)
			swap(a[i], a[rand()%i+1]); // 随机一下查找的顺序
		memset(vis, 0, sizeof vis);
		for(int i = 1; i <= n; ++i)
			if(!vis[i]){
				++ans;
				for(int j = i+1; j <= n; ++j)
					if(!mp[a[i]][a[j]])
						vis[j] = 1; // 把所有统计紧答案的人的敌人都筛去
			}
		sum = max(sum, ans);
	}
	printf("%d\n", sum);
}
```